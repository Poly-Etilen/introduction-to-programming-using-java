# 제1.1절 추가 예제 및 연습문제

## 단계별 예제

### 예제 1: 간단한 덧셈 프로그램 실행 과정

**문제:** 7 + 4를 계산하는 프로그램의 실행 과정을 추적해봅시다.

**초기 메모리 상태:**
```
주소    내용(이진수)    의미
0x200   00000111      7을 R1에 로드
0x201   00000100      4를 R2에 로드
0x202   10110001      R1 + R2 → R3
0x203   11000011      R3의 값을 메모리 0x300에 저장
0x204   11111111      프로그램 종료
```

**실행 과정:**

**사이클 1:**
- PC = 0x200
- Fetch: 00000111 읽기
- Decode: "7을 R1에 로드하라"
- Execute: R1 = 7
- PC Update: PC = 0x201

**사이클 2:**
- PC = 0x201
- Fetch: 00000100 읽기
- Decode: "4를 R2에 로드하라"
- Execute: R2 = 4
- PC Update: PC = 0x202

**사이클 3:**
- PC = 0x202
- Fetch: 10110001 읽기
- Decode: "R1과 R2를 더해서 R3에 저장하라"
- Execute: R3 = R1 + R2 = 7 + 4 = 11
- PC Update: PC = 0x203

**사이클 4:**
- PC = 0x203
- Fetch: 11000011 읽기
- Decode: "R3의 값을 메모리 0x300에 저장하라"
- Execute: 메모리[0x300] = 11
- PC Update: PC = 0x204

**사이클 5:**
- PC = 0x204
- Fetch: 11111111 읽기
- Decode: "프로그램 종료"
- Execute: CPU 정지

**최종 결과:**
- 메모리 주소 0x300에 11(십진수)이 저장됨

### 예제 2: 조건부 점프를 포함한 프로그램

**문제:** 두 수를 비교하여 큰 수를 찾는 프로그램

**메모리 상태:**
```
주소    내용         의미
0x100   00001010    10을 R1에 로드
0x101   00000111    7을 R2에 로드
0x102   11010001    R1과 R2 비교
0x103   01100110    R2가 더 크면 0x106으로 점프
0x104   10100011    R1을 R3에 복사
0x105   01110108    0x108로 점프
0x106   10100023    R2를 R3에 복사
0x107   00000000    NOP (아무것도 하지 않음)
0x108   11111111    프로그램 종료
```

**실행 추적:**
1. R1 = 10 로드
2. R2 = 7 로드
3. 10과 7 비교 (10이 더 큼)
4. 조건이 거짓이므로 점프하지 않음
5. R3 = R1 (10) 복사
6. 0x108로 점프
7. 프로그램 종료

**결과:** R3에는 큰 수인 10이 저장됨

## 연습 문제 해답

### 문제 1 해답: 이진수 변환
a) 10101010₂ = 1×128 + 0×64 + 1×32 + 0×16 + 1×8 + 0×4 + 1×2 + 0×1 = 170₁₀
b) 11110000₂ = 1×128 + 1×64 + 1×32 + 1×16 + 0×8 + 0×4 + 0×2 + 0×1 = 240₁₀
c) 00011111₂ = 0×128 + 0×64 + 0×32 + 1×16 + 1×8 + 1×4 + 1×2 + 1×1 = 31₁₀

### 문제 2 해답: 가져오기 및 실행 사이클
1. **Fetch:** PC(0x200)가 가리키는 메모리에서 명령 읽기
2. **Decode:** 명령을 "R1과 R2를 더하라"로 해석
3. **Execute:** ALU가 R1(10) + R2(20) = 30 계산
4. **Store:** 결과를 지정된 레지스터에 저장
5. **PC Update:** PC를 0x201로 업데이트

### 문제 3 해답: 개념 이해
a) CPU는 프로그램의 의미를 이해하고 실행한다 (X) - CPU는 기계적으로 실행할 뿐
b) 프로그램 카운터는 다음 실행할 명령의 주소를 저장한다 (O)
c) 1바이트는 16비트로 구성된다 (X) - 1바이트는 8비트
d) 기계어는 0과 1로만 구성된다 (O)

## 추가 연습 문제

### 문제 4: 메모리 주소 계산
메모리가 1024바이트이고 각 명령이 4바이트를 차지한다면:
a) 최대 몇 개의 명령을 저장할 수 있나요?
b) 첫 번째 명령이 주소 0x000에 있다면, 10번째 명령의 주소는?

### 문제 5: 레지스터 활용
다음 작업을 수행하는 명령 순서를 작성하세요:
1. 숫자 15를 R1에 로드
2. 숫자 25를 R2에 로드
3. R1과 R2를 더해서 R3에 저장
4. R3의 값을 2배로 만들기 (힌트: 자기 자신과 더하기)

### 문제 6: 이진수 패턴
다음 이진수 패턴이 나타낼 수 있는 것들을 설명하세요:
- 01000001
- 이것이 문자라면? 숫자라면? 명령이라면?

## 프로그래밍 사고 연습

### 시나리오 1: 계산기 프로그램
간단한 계산기가 다음 연산을 수행한다고 가정합니다:
1. 사용자로부터 첫 번째 숫자 입력
2. 사용자로부터 두 번째 숫자 입력
3. 두 숫자를 더하기
4. 결과 출력

이를 가져오기-실행 사이클로 어떻게 구현할 수 있을까요?

### 시나리오 2: 반복 작업
1부터 10까지 더하는 프로그램을 생각해봅시다:
- 어떤 레지스터가 필요할까요?
- PC를 어떻게 조작해야 반복을 구현할 수 있을까요?

## 실습 프로젝트

### 미니 프로젝트: CPU 시뮬레이터 설계
종이와 연필을 사용하여 간단한 CPU를 시뮬레이션해봅시다:

1. 4개의 레지스터 (R0, R1, R2, R3) 준비
2. 10개의 메모리 위치 (0x00 ~ 0x09) 준비
3. 다음 명령어 집합 정의:
   - LOAD Rx, 값: 값을 Rx에 로드
   - ADD Rx, Ry, Rz: Rx + Ry를 Rz에 저장
   - STORE Rx, 주소: Rx의 값을 메모리 주소에 저장
   - HALT: 프로그램 종료

4. 간단한 프로그램 작성하고 수동으로 실행해보기

## 요약 및 다음 단계

### 이번 절에서 배운 내용:
- CPU의 기본 구조와 구성 요소
- 메모리의 주소 체계와 데이터 저장 방식
- 가져오기 및 실행 사이클의 작동 원리
- 이진수 시스템과 기계어의 관계

### 다음에 배울 내용:
- 비동기 이벤트와 인터럽트 처리
- 운영체제의 역할
- 고급 프로그래밍 언어의 필요성과 발전