# 9.6 프로그래밍 연습 문제 - 학습 자료

## 학습 목표
이 장을 마치면 다음을 할 수 있습니다:
- 재귀를 활용한 다양한 문제 해결
- 연결 리스트와 이진 트리 응용 프로그램 작성
- 파서의 확장과 응용
- 복잡한 자료구조와 알고리즘 구현

## 1. 재귀 함수의 이해

### 1.1 팩토리얼(Factorial)

팩토리얼은 재귀의 고전적 예제입니다:

```java
// 재귀적 정의
factorial(0) = 1                    // 기본 경우
factorial(N) = N * factorial(N-1)   // 재귀 경우 (N > 0)

// 예시
factorial(5) = 5 * factorial(4)
             = 5 * 4 * factorial(3)
             = 5 * 4 * 3 * factorial(2)
             = 5 * 4 * 3 * 2 * factorial(1)
             = 5 * 4 * 3 * 2 * 1 * factorial(0)
             = 5 * 4 * 3 * 2 * 1 * 1
             = 120
```

### 1.2 피보나치(Fibonacci)

피보나치 수열은 재귀의 또 다른 예제입니다:

```java
// 재귀적 정의
fibonacci(0) = 1                                        // 기본 경우 1
fibonacci(1) = 1                                        // 기본 경우 2
fibonacci(N) = fibonacci(N-1) + fibonacci(N-2)          // 재귀 경우 (N > 1)

// 예시
fibonacci(5) = fibonacci(4) + fibonacci(3)
             = (fibonacci(3) + fibonacci(2)) + (fibonacci(2) + fibonacci(1))
             = ...
             = 8
```

### 1.3 재귀의 효율성 문제

**피보나치의 비효율성**:
```
fibonacci(5)를 계산하려면:
- fibonacci(4)와 fibonacci(3)를 계산
- fibonacci(4)를 위해 fibonacci(3)와 fibonacci(2)를 계산
- fibonacci(3)가 중복 계산됨!
```

더 효율적인 방법은 반복문을 사용하는 것입니다.

## 2. 이진 정렬 트리 응용

### 2.1 단어 정렬 프로그램

ArrayList 대신 이진 정렬 트리를 사용하는 이유:
- **자동 정렬**: 삽입하면서 자동으로 정렬됨
- **중복 제거**: 중복 단어를 쉽게 처리
- **효율적 검색**: O(log n) 시간 복잡도 (균형 잡힌 경우)

### 2.2 트리의 장단점

**장점**:
- 정렬된 순서 유지
- 효율적인 검색, 삽입, 삭제
- 범위 검색 가능

**단점**:
- 불균형 트리의 경우 성능 저하
- 추가 메모리 필요 (포인터)
- 구현이 복잡함

## 3. 연결 리스트 조작

### 3.1 리스트 뒤집기 알고리즘

```
원본: 1 → 2 → 3 → 4 → null
결과: 4 → 3 → 2 → 1 → null
```

**재귀적 접근**:
1. 빈 리스트는 그대로 반환
2. 한 개 노드는 그대로 반환
3. 나머지를 재귀적으로 뒤집고 현재 노드를 끝에 추가

**반복적 접근**:
1. 새 리스트를 null로 초기화
2. 원본의 각 노드를 새 리스트의 앞에 추가

## 4. 트리 순회 알고리즘

### 4.1 재귀적 순회 vs 반복적 순회

**재귀적 순회**:
- 간단하고 직관적
- 스택을 암시적으로 사용
- 깊은 트리에서 스택 오버플로우 위험

**반복적 순회 (큐 사용)**:
- 레벨 순서 순회 (너비 우선 탐색)
- 명시적인 자료구조 사용
- 메모리 사용량 예측 가능

### 4.2 큐를 사용한 레벨 순서 순회

```
트리:      1
         /   \
        2     3
       / \   / \
      4   5 6   7

레벨 순서: 1, 2, 3, 4, 5, 6, 7
```

## 5. 트리 균형 분석

### 5.1 트리 깊이의 의미

- **노드의 깊이**: 루트에서 해당 노드까지의 경로 길이
- **트리의 높이**: 가장 깊은 리프의 깊이
- **균형 잡힌 트리**: 모든 리프의 깊이가 비슷함

### 5.2 균형의 중요성

**균형 잡힌 트리**:
- 검색: O(log n)
- 삽입: O(log n)
- 삭제: O(log n)

**불균형 트리 (최악의 경우)**:
- 검색: O(n)
- 삽입: O(n)
- 삭제: O(n)

### 5.3 실험적 분석

1023개 노드의 이상적인 균형 트리:
- 높이: 9
- 모든 리프의 깊이: 9 또는 10

무작위 삽입 시:
- 평균 깊이: 약 11-13
- 최대 깊이: 약 15-20

## 6. 파서의 확장

### 6.1 변수 지원 추가

원래 수식: `3 + 4 * 5`
변수 포함: `3 + x * 5`

**필요한 변경사항**:
1. 새로운 노드 타입 (VariableNode)
2. 평가 메서드에 변수 값 전달
3. BNF 규칙 수정

### 6.2 BNF 규칙 수정

```text
<factor> ::= <number> | 
             <variable> |
             "(" <expression> ")"

<variable> ::= "x" | "X"
```

## 7. 미적분 응용 (도함수)

### 7.1 도함수 규칙

**기본 규칙**:
- 상수의 도함수: 0
- x의 도함수: 1

**연산 규칙**:
- (A + B)' = A' + B'
- (A - B)' = A' - B'
- (A * B)' = A' * B + A * B'
- (A / B)' = (A' * B - A * B') / B²

### 7.2 재귀적 도함수 계산

수식 트리의 각 노드에서:
1. 자식 노드의 도함수를 재귀적으로 계산
2. 현재 노드의 연산에 따른 도함수 규칙 적용
3. 새로운 트리 생성

### 7.3 구현의 도전 과제

**문제점**:
- 결과가 복잡해짐 (예: `3*1 + 0*x`)
- 트리가 아닌 그래프 구조가 됨
- 단순화가 어려움

**해결책**:
- 기본적인 단순화 규칙 적용
- 0과 1에 대한 특별 처리
- 공통 하위 표현식 재사용

## 8. 프로그래밍 기법

### 8.1 재귀 설계 원칙

1. **기본 경우 정의**: 재귀가 끝나는 조건
2. **재귀 경우 정의**: 문제를 작게 만드는 방법
3. **진행 보장**: 항상 기본 경우를 향해 진행

### 8.2 트리 알고리즘 패턴

**일반적인 재귀 패턴**:
```java
void processTree(Node node) {
    if (node == null) return;  // 기본 경우
    
    // 현재 노드 처리
    process(node);
    
    // 자식 노드 재귀 처리
    processTree(node.left);
    processTree(node.right);
}
```

### 8.3 디버깅 팁

1. **작은 예제로 시작**: 간단한 입력으로 테스트
2. **중간 결과 출력**: 각 단계의 상태 확인
3. **시각화**: 트리나 리스트 구조를 그려보기
4. **단위 테스트**: 각 메서드를 독립적으로 테스트

## 마무리

이러한 연습 문제들은 재귀와 자료구조의 실제 응용을 보여줍니다:

1. **재귀의 강점과 약점**: 언제 사용하고 언제 피해야 하는지
2. **자료구조 선택**: 문제에 맞는 적절한 구조 선택
3. **알고리즘 분석**: 효율성과 정확성의 균형
4. **확장성**: 기존 코드를 새로운 요구사항에 맞게 수정

이러한 기술은 실제 프로그래밍에서 매우 중요합니다!