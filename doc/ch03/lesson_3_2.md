# 3.2 알고리즘 개발 - 학습 자료

## 학습 목표
이 장을 마치면 다음을 할 수 있습니다:
- 알고리즘의 개념과 중요성을 이해한다
- 의사코드를 사용하여 문제를 분석할 수 있다
- 단계적 세분화 기법을 적용할 수 있다
- 체계적인 디버깅 방법을 익힌다
- 완전한 프로그램을 개발하는 과정을 경험한다

## 1. 알고리즘이란?

### 1.1 알고리즘의 정의
**알고리즘**: 문제를 해결하기 위한 명확하고 단계적인 절차

### 1.2 알고리즘의 특징
- **명확성**: 각 단계가 모호하지 않고 정확함
- **유한성**: 반드시 종료되어야 함
- **효과성**: 실제로 수행 가능한 단계들로 구성
- **입출력**: 입력을 받아 출력을 생성

### 1.3 프로그램과 알고리즘의 차이
```
알고리즘 (아이디어)
    ↓
의사코드 (중간 단계)
    ↓
프로그램 (구현)
```

💡 **핵심**: 알고리즘은 언어 독립적인 문제 해결 방법입니다!

## 2. 의사코드 (Pseudocode)

### 2.1 의사코드란?
프로그래밍 언어의 구조를 따르지만 자연어로 작성된 알고리즘 표현

### 2.2 의사코드의 장점
- 문법에 얽매이지 않음
- 논리에 집중 가능
- 언어 독립적
- 수정이 쉬움

### 2.3 의사코드 예시
```pseudocode
// 최댓값 찾기
최댓값 = 첫 번째 숫자
for 각 숫자 in 리스트:
    if 숫자 > 최댓값:
        최댓값 = 숫자
최댓값 출력
```

## 3. 단계적 세분화 (Stepwise Refinement)

### 3.1 개념
복잡한 문제를 점진적으로 더 구체적인 단계로 나누는 기법

### 3.2 단계적 세분화 과정
```
1단계: 전체 작업 설명
    ↓
2단계: 주요 단계로 분해
    ↓
3단계: 각 단계를 세부 단계로 분해
    ↓
4단계: 프로그래밍 언어로 변환 가능한 수준까지 세분화
```

### 3.3 실제 예시: 이자 계산 프로그램

**1단계 - 전체 작업**:
```pseudocode
5년간 투자 가치 계산 및 출력
```

**2단계 - 주요 단계**:
```pseudocode
사용자 입력 받기
5년 동안 반복:
    이자 계산
    결과 출력
```

**3단계 - 세부 단계**:
```pseudocode
원금 입력받기
이자율 입력받기
years = 0
while years < 5:
    years = years + 1
    이자 = 원금 * 이자율
    원금 = 원금 + 이자
    원금 출력
```

**4단계 - Java 코드**:
```java
double principal = TextIO.getlnDouble();
double rate = TextIO.getlnDouble();
int years = 0;
while (years < 5) {
    years = years + 1;
    double interest = principal * rate;
    principal = principal + interest;
    System.out.println(principal);
}
```

## 4. 3N+1 문제 예시

### 4.1 문제 설명
양의 정수 N에서 시작하여:
- N이 짝수면: N을 2로 나눔
- N이 홀수면: 3*N + 1
- N이 1이 될 때까지 반복

### 4.2 알고리즘 개발 과정

**초기 설계**:
```pseudocode
N 입력받기
N이 1이 될 때까지 반복
항의 개수 출력
```

**세분화 1**:
```pseudocode
N 입력받기
while N ≠ 1:
    다음 항 계산
    출력
    카운트
개수 출력
```

**세분화 2**:
```pseudocode
N 입력받기
counter = 0
while N ≠ 1:
    if N이 짝수:
        N = N / 2
    else:
        N = 3 * N + 1
    N 출력
    counter++
counter 출력
```

### 4.3 입력 검증 추가
```pseudocode
do:
    N 입력받기
    if N <= 0:
        오류 메시지
while N <= 0

// 이제 N > 0 보장됨
// 3N+1 알고리즘 실행
```

## 5. 알고리즘 패턴

### 5.1 카운팅 루프
```java
// 패턴: 0부터 시작, 조건까지 반복
int count = 0;
while (count < 목표값) {
    // 작업 수행
    count++;
}
```

### 5.2 입력 검증 루프
```java
// 패턴: 올바른 입력까지 반복
int input;
do {
    System.out.print("양수 입력: ");
    input = TextIO.getlnInt();
} while (input <= 0);
```

### 5.3 누적 패턴
```java
// 패턴: 값을 누적
double sum = 0;
while (조건) {
    double value = 다음값();
    sum = sum + value;
}
```

## 6. 코딩, 테스트, 디버깅

### 6.1 개발 단계
```
설계 → 코딩 → 컴파일 → 테스트 → 디버깅
  ↑                                    ↓
  ←────────────────────────────────────┘
```

### 6.2 일반적인 오류 유형

**구문 오류 (Syntax Errors)**:
- 컴파일러가 감지
- 문법 규칙 위반
- 예: 세미콜론 누락, 괄호 불일치

**논리 오류 (Logic Errors)**:
- 프로그램은 실행되지만 잘못된 결과
- 알고리즘의 오류
- 예: 잘못된 조건, 계산 실수

### 6.3 디버깅 전략

**1. 디버깅 출력문 사용**:
```java
System.out.println("루프 시작: N = " + N);
// 의심스러운 코드
System.out.println("루프 종료: N = " + N);
```

**2. 단계별 추적**:
- 종이에 변수값 기록
- 각 단계마다 상태 확인
- 예상값과 실제값 비교

**3. 분할 정복**:
- 프로그램을 작은 부분으로 나누기
- 각 부분을 독립적으로 테스트
- 문제 영역 좁히기

### 6.4 테스트 전략

**경계값 테스트**:
- 최소값, 최대값
- 0, 1, -1
- 빈 입력

**일반 케이스**:
- 정상적인 입력
- 다양한 크기의 데이터

**예외 케이스**:
- 잘못된 입력
- 극단적인 값

## 7. 좋은 프로그래밍 습관

### 7.1 코딩 스타일
```java
// 좋은 예
if (x > 0) {
    // 명확한 들여쓰기
    x = x * 2;
}

// 나쁜 예
if(x>0){x=x*2;}
```

### 7.2 변수명 규칙
```java
// 의미 있는 이름 사용
int studentCount;  // 좋음
int sc;           // 나쁨
int x;            // 매우 나쁨
```

### 7.3 주석 작성
```java
// 계산 전 입력 검증
if (rate < 0 || rate > 1) {
    System.out.println("이자율은 0과 1 사이여야 합니다");
    return;
}
```

## 실습 체크리스트

알고리즘 개발 시 확인사항:
- [ ] 문제를 완전히 이해했는가?
- [ ] 입력과 출력이 명확한가?
- [ ] 의사코드로 먼저 작성했는가?
- [ ] 단계적으로 세분화했는가?
- [ ] 모든 경우를 고려했는가?
- [ ] 종료 조건이 명확한가?
- [ ] 테스트 케이스를 준비했는가?
- [ ] 디버깅 계획이 있는가?

## 요약

알고리즘 개발은 체계적인 과정입니다:
1. **문제 이해**: 정확한 요구사항 파악
2. **설계**: 의사코드와 단계적 세분화
3. **구현**: 설계를 코드로 변환
4. **테스트**: 다양한 입력으로 검증
5. **디버깅**: 오류 찾기와 수정

💡 **기억하세요**: 좋은 알고리즘은 한 번에 만들어지지 않습니다. 반복적인 개선이 핵심입니다!